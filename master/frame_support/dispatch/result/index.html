<!DOCTYPE html><html lang="en"><head><link rel="canonical" href="https://paritytech.github.io/polkadot-sdk/master/frame_support/dispatch/result/index.html"><meta http-equiv="refresh" content="0;URL='https://paritytech.github.io/polkadot-sdk/master/frame_support/dispatch/result/index.html'"><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Error handling with the `Result` type."><title>frame_support::dispatch::result - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-ba5701c5741a7b69.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="frame_support" data-themes="" data-resource-suffix="" data-rustdoc-version="1.70.0 (90c541806 2023-05-31)" data-search-js="search-e077946657036a58.js" data-settings-js="settings-298e1ea74db45b39.js" data-settings-css="settings-7bfb4c59cc6bc502.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../../../static.files/storage-62ce34ea385b278a.js"></script><script defer src="../../../static.files/main-f61008743c98d196.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../../frame_support/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../../frame_support/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Module result</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../../index.html">frame_support</a>::<wbr><a href="../index.html">dispatch</a>::<wbr><a class="mod" href="#">result</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.70.0/src/core/lib.rs.html#367">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Error handling with the <code>Result</code> type.</p>
<p><a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result&lt;T, E&gt;</code></a> is the type used for returning and propagating
errors. It is an enum with the variants, <a href="enum.Result.html#variant.Ok" title="variant frame_support::dispatch::result::Result::Ok"><code>Ok(T)</code></a>, representing
success and containing a value, and <a href="enum.Result.html#variant.Err" title="variant frame_support::dispatch::result::Result::Err"><code>Err(E)</code></a>, representing error
and containing an error value.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">enum </span><span class="prelude-ty">Result</span>&lt;T, E&gt; {
   <span class="prelude-val">Ok</span>(T),
   <span class="prelude-val">Err</span>(E),
}</code></pre></div>
<p>Functions return <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result</code></a> whenever errors are expected and
recoverable. In the <code>std</code> crate, <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result</code></a> is most prominently used
for <a href="../../std/io/index.html">I/O</a>.</p>
<p>A simple function returning <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result</code></a> might be
defined and used like so:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Debug)]
</span><span class="kw">enum </span>Version { Version1, Version2 }

<span class="kw">fn </span>parse_version(header: <span class="kw-2">&amp;</span>[u8]) -&gt; <span class="prelude-ty">Result</span>&lt;Version, <span class="kw-2">&amp;</span><span class="lifetime">&#39;static </span>str&gt; {
    <span class="kw">match </span>header.get(<span class="number">0</span>) {
        <span class="prelude-val">None </span>=&gt; <span class="prelude-val">Err</span>(<span class="string">&quot;invalid header length&quot;</span>),
        <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">1</span>) =&gt; <span class="prelude-val">Ok</span>(Version::Version1),
        <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">2</span>) =&gt; <span class="prelude-val">Ok</span>(Version::Version2),
        <span class="prelude-val">Some</span>(<span class="kw">_</span>) =&gt; <span class="prelude-val">Err</span>(<span class="string">&quot;invalid version&quot;</span>),
    }
}

<span class="kw">let </span>version = parse_version(<span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);
<span class="kw">match </span>version {
    <span class="prelude-val">Ok</span>(v) =&gt; <span class="macro">println!</span>(<span class="string">&quot;working with version: {v:?}&quot;</span>),
    <span class="prelude-val">Err</span>(e) =&gt; <span class="macro">println!</span>(<span class="string">&quot;error parsing header: {e:?}&quot;</span>),
}</code></pre></div>
<p>Pattern matching on <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result</code></a>s is clear and straightforward for
simple cases, but <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result</code></a> comes with some convenience methods
that make working with it more succinct.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>good_result: <span class="prelude-ty">Result</span>&lt;i32, i32&gt; = <span class="prelude-val">Ok</span>(<span class="number">10</span>);
<span class="kw">let </span>bad_result: <span class="prelude-ty">Result</span>&lt;i32, i32&gt; = <span class="prelude-val">Err</span>(<span class="number">10</span>);

<span class="comment">// The `is_ok` and `is_err` methods do what they say.
</span><span class="macro">assert!</span>(good_result.is_ok() &amp;&amp; !good_result.is_err());
<span class="macro">assert!</span>(bad_result.is_err() &amp;&amp; !bad_result.is_ok());

<span class="comment">// `map` consumes the `Result` and produces another.
</span><span class="kw">let </span>good_result: <span class="prelude-ty">Result</span>&lt;i32, i32&gt; = good_result.map(|i| i + <span class="number">1</span>);
<span class="kw">let </span>bad_result: <span class="prelude-ty">Result</span>&lt;i32, i32&gt; = bad_result.map(|i| i - <span class="number">1</span>);

<span class="comment">// Use `and_then` to continue the computation.
</span><span class="kw">let </span>good_result: <span class="prelude-ty">Result</span>&lt;bool, i32&gt; = good_result.and_then(|i| <span class="prelude-val">Ok</span>(i == <span class="number">11</span>));

<span class="comment">// Use `or_else` to handle the error.
</span><span class="kw">let </span>bad_result: <span class="prelude-ty">Result</span>&lt;i32, i32&gt; = bad_result.or_else(|i| <span class="prelude-val">Ok</span>(i + <span class="number">20</span>));

<span class="comment">// Consume the result and return the contents with `unwrap`.
</span><span class="kw">let </span>final_awesome_result = good_result.unwrap();</code></pre></div>
<h2 id="results-must-be-used"><a href="#results-must-be-used">Results must be used</a></h2>
<p>A common problem with using return values to indicate errors is
that it is easy to ignore the return value, thus failing to handle
the error. <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result</code></a> is annotated with the <code>#[must_use]</code> attribute,
which will cause the compiler to issue a warning when a Result
value is ignored. This makes <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result</code></a> especially useful with
functions that may encounter errors but don’t otherwise return a
useful value.</p>
<p>Consider the <a href="../../std/io/trait.Write.html#method.write_all" title="io::Write::write_all"><code>write_all</code></a> method defined for I/O types
by the <a href="../../std/io/trait.Write.html" title="io::Write"><code>Write</code></a> trait:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::io;

<span class="kw">trait </span>Write {
    <span class="kw">fn </span>write_all(<span class="kw-2">&amp;mut </span><span class="self">self</span>, bytes: <span class="kw-2">&amp;</span>[u8]) -&gt; <span class="prelude-ty">Result</span>&lt;(), io::Error&gt;;
}</code></pre></div>
<p><em>Note: The actual definition of <a href="../../std/io/trait.Write.html" title="io::Write"><code>Write</code></a> uses <a href="../../std/io/type.Result.html" title="io::Result"><code>io::Result</code></a>, which
is just a synonym for <code><a href="enum.Result.html" title="enum frame_support::dispatch::result::Result">Result</a>&lt;T, <a href="../../std/io/struct.Error.html" title="io::Error">io::Error</a>&gt;</code>.</em></p>
<p>This method doesn’t produce a value, but the write may
fail. It’s crucial to handle the error case, and <em>not</em> write
something like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::fs::File;
<span class="kw">use </span>std::io::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>file = File::create(<span class="string">&quot;valuable_data.txt&quot;</span>).unwrap();
<span class="comment">// If `write_all` errors, then we&#39;ll never know, because the return
// value is ignored.
</span>file.write_all(<span class="string">b&quot;important message&quot;</span>);</code></pre></div>
<p>If you <em>do</em> write that in Rust, the compiler will give you a
warning (by default, controlled by the <code>unused_must_use</code> lint).</p>
<p>You might instead, if you don’t want to handle the error, simply
assert success with <a href="enum.Result.html#method.expect" title="method frame_support::dispatch::result::Result::expect"><code>expect</code></a>. This will panic if the
write fails, providing a marginally useful message indicating why:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::fs::File;
<span class="kw">use </span>std::io::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>file = File::create(<span class="string">&quot;valuable_data.txt&quot;</span>).unwrap();
file.write_all(<span class="string">b&quot;important message&quot;</span>).expect(<span class="string">&quot;failed to write message&quot;</span>);</code></pre></div>
<p>You might also simply assert success:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert!</span>(file.write_all(<span class="string">b&quot;important message&quot;</span>).is_ok());</code></pre></div>
<p>Or propagate the error up the call stack with <a href="https://doc.rust-lang.org/1.70.0/core/ops/try_trait/trait.Try.html" title="trait core::ops::try_trait::Try"><code>?</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>write_message() -&gt; io::Result&lt;()&gt; {
    <span class="kw">let </span><span class="kw-2">mut </span>file = File::create(<span class="string">&quot;valuable_data.txt&quot;</span>)<span class="question-mark">?</span>;
    file.write_all(<span class="string">b&quot;important message&quot;</span>)<span class="question-mark">?</span>;
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<h2 id="the-question-mark-operator-"><a href="#the-question-mark-operator-">The question mark operator, <code>?</code></a></h2>
<p>When writing code that calls many functions that return the
<a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result</code></a> type, the error handling can be tedious. The question mark
operator, <a href="https://doc.rust-lang.org/1.70.0/core/ops/try_trait/trait.Try.html" title="trait core::ops::try_trait::Try"><code>?</code></a>, hides some of the boilerplate of propagating errors
up the call stack.</p>
<p>It replaces this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::fs::File;
<span class="kw">use </span>std::io::prelude::<span class="kw-2">*</span>;
<span class="kw">use </span>std::io;

<span class="kw">struct </span>Info {
    name: String,
    age: i32,
    rating: i32,
}

<span class="kw">fn </span>write_info(info: <span class="kw-2">&amp;</span>Info) -&gt; io::Result&lt;()&gt; {
    <span class="comment">// Early return on error
    </span><span class="kw">let </span><span class="kw-2">mut </span>file = <span class="kw">match </span>File::create(<span class="string">&quot;my_best_friends.txt&quot;</span>) {
           <span class="prelude-val">Err</span>(e) =&gt; <span class="kw">return </span><span class="prelude-val">Err</span>(e),
           <span class="prelude-val">Ok</span>(f) =&gt; f,
    };
    <span class="kw">if let </span><span class="prelude-val">Err</span>(e) = file.write_all(<span class="macro">format!</span>(<span class="string">&quot;name: {}\n&quot;</span>, info.name).as_bytes()) {
        <span class="kw">return </span><span class="prelude-val">Err</span>(e)
    }
    <span class="kw">if let </span><span class="prelude-val">Err</span>(e) = file.write_all(<span class="macro">format!</span>(<span class="string">&quot;age: {}\n&quot;</span>, info.age).as_bytes()) {
        <span class="kw">return </span><span class="prelude-val">Err</span>(e)
    }
    <span class="kw">if let </span><span class="prelude-val">Err</span>(e) = file.write_all(<span class="macro">format!</span>(<span class="string">&quot;rating: {}\n&quot;</span>, info.rating).as_bytes()) {
        <span class="kw">return </span><span class="prelude-val">Err</span>(e)
    }
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<p>With this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::fs::File;
<span class="kw">use </span>std::io::prelude::<span class="kw-2">*</span>;
<span class="kw">use </span>std::io;

<span class="kw">struct </span>Info {
    name: String,
    age: i32,
    rating: i32,
}

<span class="kw">fn </span>write_info(info: <span class="kw-2">&amp;</span>Info) -&gt; io::Result&lt;()&gt; {
    <span class="kw">let </span><span class="kw-2">mut </span>file = File::create(<span class="string">&quot;my_best_friends.txt&quot;</span>)<span class="question-mark">?</span>;
    <span class="comment">// Early return on error
    </span>file.write_all(<span class="macro">format!</span>(<span class="string">&quot;name: {}\n&quot;</span>, info.name).as_bytes())<span class="question-mark">?</span>;
    file.write_all(<span class="macro">format!</span>(<span class="string">&quot;age: {}\n&quot;</span>, info.age).as_bytes())<span class="question-mark">?</span>;
    file.write_all(<span class="macro">format!</span>(<span class="string">&quot;rating: {}\n&quot;</span>, info.rating).as_bytes())<span class="question-mark">?</span>;
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<p><em>It’s much nicer!</em></p>
<p>Ending the expression with <a href="https://doc.rust-lang.org/1.70.0/core/ops/try_trait/trait.Try.html" title="trait core::ops::try_trait::Try"><code>?</code></a> will result in the <a href="enum.Result.html#variant.Ok" title="variant frame_support::dispatch::result::Result::Ok"><code>Ok</code></a>’s unwrapped value, unless the result
is <a href="enum.Result.html#variant.Err" title="variant frame_support::dispatch::result::Result::Err"><code>Err</code></a>, in which case <a href="enum.Result.html#variant.Err" title="variant frame_support::dispatch::result::Result::Err"><code>Err</code></a> is returned early from the enclosing function.</p>
<p><a href="https://doc.rust-lang.org/1.70.0/core/ops/try_trait/trait.Try.html" title="trait core::ops::try_trait::Try"><code>?</code></a> can be used in functions that return <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result</code></a> because of the
early return of <a href="enum.Result.html#variant.Err" title="variant frame_support::dispatch::result::Result::Err"><code>Err</code></a> that it provides.</p>
<h2 id="method-overview"><a href="#method-overview">Method overview</a></h2>
<p>In addition to working with pattern matching, <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result</code></a> provides a
wide variety of different methods.</p>
<h3 id="querying-the-variant"><a href="#querying-the-variant">Querying the variant</a></h3>
<p>The <a href="enum.Result.html#method.is_ok" title="method frame_support::dispatch::result::Result::is_ok"><code>is_ok</code></a> and <a href="enum.Result.html#method.is_err" title="method frame_support::dispatch::result::Result::is_err"><code>is_err</code></a> methods return <a href="https://doc.rust-lang.org/1.70.0/std/primitive.bool.html" title="primitive bool"><code>true</code></a> if the <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result</code></a>
is <a href="enum.Result.html#variant.Ok" title="variant frame_support::dispatch::result::Result::Ok"><code>Ok</code></a> or <a href="enum.Result.html#variant.Err" title="variant frame_support::dispatch::result::Result::Err"><code>Err</code></a>, respectively.</p>
<h3 id="adapters-for-working-with-references"><a href="#adapters-for-working-with-references">Adapters for working with references</a></h3>
<ul>
<li><a href="enum.Result.html#method.as_ref" title="method frame_support::dispatch::result::Result::as_ref"><code>as_ref</code></a> converts from <code>&amp;Result&lt;T, E&gt;</code> to <code>Result&lt;&amp;T, &amp;E&gt;</code></li>
<li><a href="enum.Result.html#method.as_mut" title="method frame_support::dispatch::result::Result::as_mut"><code>as_mut</code></a> converts from <code>&amp;mut Result&lt;T, E&gt;</code> to <code>Result&lt;&amp;mut T, &amp;mut E&gt;</code></li>
<li><a href="enum.Result.html#method.as_deref" title="method frame_support::dispatch::result::Result::as_deref"><code>as_deref</code></a> converts from <code>&amp;Result&lt;T, E&gt;</code> to <code>Result&lt;&amp;T::Target, &amp;E&gt;</code></li>
<li><a href="enum.Result.html#method.as_deref_mut" title="method frame_support::dispatch::result::Result::as_deref_mut"><code>as_deref_mut</code></a> converts from <code>&amp;mut Result&lt;T, E&gt;</code> to
<code>Result&lt;&amp;mut T::Target, &amp;mut E&gt;</code></li>
</ul>
<h3 id="extracting-contained-values"><a href="#extracting-contained-values">Extracting contained values</a></h3>
<p>These methods extract the contained value in a <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result&lt;T, E&gt;</code></a> when it
is the <a href="enum.Result.html#variant.Ok" title="variant frame_support::dispatch::result::Result::Ok"><code>Ok</code></a> variant. If the <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result</code></a> is <a href="enum.Result.html#variant.Err" title="variant frame_support::dispatch::result::Result::Err"><code>Err</code></a>:</p>
<ul>
<li><a href="enum.Result.html#method.expect" title="method frame_support::dispatch::result::Result::expect"><code>expect</code></a> panics with a provided custom message</li>
<li><a href="enum.Result.html#method.unwrap" title="method frame_support::dispatch::result::Result::unwrap"><code>unwrap</code></a> panics with a generic message</li>
<li><a href="enum.Result.html#method.unwrap_or" title="method frame_support::dispatch::result::Result::unwrap_or"><code>unwrap_or</code></a> returns the provided default value</li>
<li><a href="enum.Result.html#method.unwrap_or_default" title="method frame_support::dispatch::result::Result::unwrap_or_default"><code>unwrap_or_default</code></a> returns the default value of the type <code>T</code>
(which must implement the <a href="https://doc.rust-lang.org/1.70.0/core/default/trait.Default.html" title="trait core::default::Default"><code>Default</code></a> trait)</li>
<li><a href="enum.Result.html#method.unwrap_or_else" title="method frame_support::dispatch::result::Result::unwrap_or_else"><code>unwrap_or_else</code></a> returns the result of evaluating the provided
function</li>
</ul>
<p>The panicking methods <a href="enum.Result.html#method.expect" title="method frame_support::dispatch::result::Result::expect"><code>expect</code></a> and <a href="enum.Result.html#method.unwrap" title="method frame_support::dispatch::result::Result::unwrap"><code>unwrap</code></a> require <code>E</code> to
implement the <a href="../fmt/trait.Debug.html" title="trait frame_support::dispatch::fmt::Debug"><code>Debug</code></a> trait.</p>
<p>These methods extract the contained value in a <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result&lt;T, E&gt;</code></a> when it
is the <a href="enum.Result.html#variant.Err" title="variant frame_support::dispatch::result::Result::Err"><code>Err</code></a> variant. They require <code>T</code> to implement the <a href="../fmt/trait.Debug.html" title="trait frame_support::dispatch::fmt::Debug"><code>Debug</code></a>
trait. If the <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result</code></a> is <a href="enum.Result.html#variant.Ok" title="variant frame_support::dispatch::result::Result::Ok"><code>Ok</code></a>:</p>
<ul>
<li><a href="enum.Result.html#method.expect_err" title="method frame_support::dispatch::result::Result::expect_err"><code>expect_err</code></a> panics with a provided custom message</li>
<li><a href="enum.Result.html#method.unwrap_err" title="method frame_support::dispatch::result::Result::unwrap_err"><code>unwrap_err</code></a> panics with a generic message</li>
</ul>
<h3 id="transforming-contained-values"><a href="#transforming-contained-values">Transforming contained values</a></h3>
<p>These methods transform <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result</code></a> to <a href="https://doc.rust-lang.org/1.70.0/core/option/enum.Option.html" title="enum core::option::Option"><code>Option</code></a>:</p>
<ul>
<li><a href="enum.Result.html#method.err" title="method frame_support::dispatch::result::Result::err"><code>err</code></a> transforms <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result&lt;T, E&gt;</code></a> into <a href="https://doc.rust-lang.org/1.70.0/core/option/enum.Option.html" title="enum core::option::Option"><code>Option&lt;E&gt;</code></a>,
mapping <a href="enum.Result.html#variant.Err" title="variant frame_support::dispatch::result::Result::Err"><code>Err(e)</code></a> to <a href="https://doc.rust-lang.org/1.70.0/core/option/enum.Option.html#variant.Some" title="variant core::option::Option::Some"><code>Some(e)</code></a> and <a href="enum.Result.html#variant.Ok" title="variant frame_support::dispatch::result::Result::Ok"><code>Ok(v)</code></a> to <a href="https://doc.rust-lang.org/1.70.0/core/option/enum.Option.html#variant.None" title="variant core::option::Option::None"><code>None</code></a></li>
<li><a href="enum.Result.html#method.ok" title="method frame_support::dispatch::result::Result::ok"><code>ok</code></a> transforms <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result&lt;T, E&gt;</code></a> into <a href="https://doc.rust-lang.org/1.70.0/core/option/enum.Option.html" title="enum core::option::Option"><code>Option&lt;T&gt;</code></a>,
mapping <a href="enum.Result.html#variant.Ok" title="variant frame_support::dispatch::result::Result::Ok"><code>Ok(v)</code></a> to <a href="https://doc.rust-lang.org/1.70.0/core/option/enum.Option.html#variant.Some" title="variant core::option::Option::Some"><code>Some(v)</code></a> and <a href="enum.Result.html#variant.Err" title="variant frame_support::dispatch::result::Result::Err"><code>Err(e)</code></a> to <a href="https://doc.rust-lang.org/1.70.0/core/option/enum.Option.html#variant.None" title="variant core::option::Option::None"><code>None</code></a></li>
<li><a href="enum.Result.html#method.transpose" title="method frame_support::dispatch::result::Result::transpose"><code>transpose</code></a> transposes a <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result</code></a> of an <a href="https://doc.rust-lang.org/1.70.0/core/option/enum.Option.html" title="enum core::option::Option"><code>Option</code></a> into an
<a href="https://doc.rust-lang.org/1.70.0/core/option/enum.Option.html" title="enum core::option::Option"><code>Option</code></a> of a <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result</code></a></li>
</ul>
<p>This method transforms the contained value of the <a href="enum.Result.html#variant.Ok" title="variant frame_support::dispatch::result::Result::Ok"><code>Ok</code></a> variant:</p>
<ul>
<li><a href="enum.Result.html#method.map" title="method frame_support::dispatch::result::Result::map"><code>map</code></a> transforms <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result&lt;T, E&gt;</code></a> into <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result&lt;U, E&gt;</code></a> by applying
the provided function to the contained value of <a href="enum.Result.html#variant.Ok" title="variant frame_support::dispatch::result::Result::Ok"><code>Ok</code></a> and leaving
<a href="enum.Result.html#variant.Err" title="variant frame_support::dispatch::result::Result::Err"><code>Err</code></a> values unchanged</li>
</ul>
<p>This method transforms the contained value of the <a href="enum.Result.html#variant.Err" title="variant frame_support::dispatch::result::Result::Err"><code>Err</code></a> variant:</p>
<ul>
<li><a href="enum.Result.html#method.map_err" title="method frame_support::dispatch::result::Result::map_err"><code>map_err</code></a> transforms <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result&lt;T, E&gt;</code></a> into <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result&lt;T, F&gt;</code></a> by
applying the provided function to the contained value of <a href="enum.Result.html#variant.Err" title="variant frame_support::dispatch::result::Result::Err"><code>Err</code></a> and
leaving <a href="enum.Result.html#variant.Ok" title="variant frame_support::dispatch::result::Result::Ok"><code>Ok</code></a> values unchanged</li>
</ul>
<p>These methods transform a <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result&lt;T, E&gt;</code></a> into a value of a possibly
different type <code>U</code>:</p>
<ul>
<li><a href="enum.Result.html#method.map_or" title="method frame_support::dispatch::result::Result::map_or"><code>map_or</code></a> applies the provided function to the contained value of
<a href="enum.Result.html#variant.Ok" title="variant frame_support::dispatch::result::Result::Ok"><code>Ok</code></a>, or returns the provided default value if the <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result</code></a> is
<a href="enum.Result.html#variant.Err" title="variant frame_support::dispatch::result::Result::Err"><code>Err</code></a></li>
<li><a href="enum.Result.html#method.map_or_else" title="method frame_support::dispatch::result::Result::map_or_else"><code>map_or_else</code></a> applies the provided function to the contained value
of <a href="enum.Result.html#variant.Ok" title="variant frame_support::dispatch::result::Result::Ok"><code>Ok</code></a>, or applies the provided default fallback function to the
contained value of <a href="enum.Result.html#variant.Err" title="variant frame_support::dispatch::result::Result::Err"><code>Err</code></a></li>
</ul>
<h3 id="boolean-operators"><a href="#boolean-operators">Boolean operators</a></h3>
<p>These methods treat the <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result</code></a> as a boolean value, where <a href="enum.Result.html#variant.Ok" title="variant frame_support::dispatch::result::Result::Ok"><code>Ok</code></a>
acts like <a href="https://doc.rust-lang.org/1.70.0/std/primitive.bool.html" title="primitive bool"><code>true</code></a> and <a href="enum.Result.html#variant.Err" title="variant frame_support::dispatch::result::Result::Err"><code>Err</code></a> acts like <a href="https://doc.rust-lang.org/1.70.0/std/primitive.bool.html" title="primitive bool"><code>false</code></a>. There are two
categories of these methods: ones that take a <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result</code></a> as input, and
ones that take a function as input (to be lazily evaluated).</p>
<p>The <a href="enum.Result.html#method.and" title="method frame_support::dispatch::result::Result::and"><code>and</code></a> and <a href="enum.Result.html#method.or" title="method frame_support::dispatch::result::Result::or"><code>or</code></a> methods take another <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result</code></a> as input, and
produce a <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result</code></a> as output. The <a href="enum.Result.html#method.and" title="method frame_support::dispatch::result::Result::and"><code>and</code></a> method can produce a
<a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result&lt;U, E&gt;</code></a> value having a different inner type <code>U</code> than
<a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result&lt;T, E&gt;</code></a>. The <a href="enum.Result.html#method.or" title="method frame_support::dispatch::result::Result::or"><code>or</code></a> method can produce a <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result&lt;T, F&gt;</code></a>
value having a different error type <code>F</code> than <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result&lt;T, E&gt;</code></a>.</p>
<div><table><thead><tr><th>method</th><th>self</th><th>input</th><th>output</th></tr></thead><tbody>
<tr><td><a href="enum.Result.html#method.and" title="method frame_support::dispatch::result::Result::and"><code>and</code></a></td><td><code>Err(e)</code></td><td>(ignored)</td><td><code>Err(e)</code></td></tr>
<tr><td><a href="enum.Result.html#method.and" title="method frame_support::dispatch::result::Result::and"><code>and</code></a></td><td><code>Ok(x)</code></td><td><code>Err(d)</code></td><td><code>Err(d)</code></td></tr>
<tr><td><a href="enum.Result.html#method.and" title="method frame_support::dispatch::result::Result::and"><code>and</code></a></td><td><code>Ok(x)</code></td><td><code>Ok(y)</code></td><td><code>Ok(y)</code></td></tr>
<tr><td><a href="enum.Result.html#method.or" title="method frame_support::dispatch::result::Result::or"><code>or</code></a></td><td><code>Err(e)</code></td><td><code>Err(d)</code></td><td><code>Err(d)</code></td></tr>
<tr><td><a href="enum.Result.html#method.or" title="method frame_support::dispatch::result::Result::or"><code>or</code></a></td><td><code>Err(e)</code></td><td><code>Ok(y)</code></td><td><code>Ok(y)</code></td></tr>
<tr><td><a href="enum.Result.html#method.or" title="method frame_support::dispatch::result::Result::or"><code>or</code></a></td><td><code>Ok(x)</code></td><td>(ignored)</td><td><code>Ok(x)</code></td></tr>
</tbody></table>
</div>
<p>The <a href="enum.Result.html#method.and_then" title="method frame_support::dispatch::result::Result::and_then"><code>and_then</code></a> and <a href="enum.Result.html#method.or_else" title="method frame_support::dispatch::result::Result::or_else"><code>or_else</code></a> methods take a function as input, and
only evaluate the function when they need to produce a new value. The
<a href="enum.Result.html#method.and_then" title="method frame_support::dispatch::result::Result::and_then"><code>and_then</code></a> method can produce a <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result&lt;U, E&gt;</code></a> value having a
different inner type <code>U</code> than <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result&lt;T, E&gt;</code></a>. The <a href="enum.Result.html#method.or_else" title="method frame_support::dispatch::result::Result::or_else"><code>or_else</code></a> method
can produce a <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result&lt;T, F&gt;</code></a> value having a different error type <code>F</code>
than <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result&lt;T, E&gt;</code></a>.</p>
<div><table><thead><tr><th>method</th><th>self</th><th>function input</th><th>function result</th><th>output</th></tr></thead><tbody>
<tr><td><a href="enum.Result.html#method.and_then" title="method frame_support::dispatch::result::Result::and_then"><code>and_then</code></a></td><td><code>Err(e)</code></td><td>(not provided)</td><td>(not evaluated)</td><td><code>Err(e)</code></td></tr>
<tr><td><a href="enum.Result.html#method.and_then" title="method frame_support::dispatch::result::Result::and_then"><code>and_then</code></a></td><td><code>Ok(x)</code></td><td><code>x</code></td><td><code>Err(d)</code></td><td><code>Err(d)</code></td></tr>
<tr><td><a href="enum.Result.html#method.and_then" title="method frame_support::dispatch::result::Result::and_then"><code>and_then</code></a></td><td><code>Ok(x)</code></td><td><code>x</code></td><td><code>Ok(y)</code></td><td><code>Ok(y)</code></td></tr>
<tr><td><a href="enum.Result.html#method.or_else" title="method frame_support::dispatch::result::Result::or_else"><code>or_else</code></a></td><td><code>Err(e)</code></td><td><code>e</code></td><td><code>Err(d)</code></td><td><code>Err(d)</code></td></tr>
<tr><td><a href="enum.Result.html#method.or_else" title="method frame_support::dispatch::result::Result::or_else"><code>or_else</code></a></td><td><code>Err(e)</code></td><td><code>e</code></td><td><code>Ok(y)</code></td><td><code>Ok(y)</code></td></tr>
<tr><td><a href="enum.Result.html#method.or_else" title="method frame_support::dispatch::result::Result::or_else"><code>or_else</code></a></td><td><code>Ok(x)</code></td><td>(not provided)</td><td>(not evaluated)</td><td><code>Ok(x)</code></td></tr>
</tbody></table>
</div><h3 id="comparison-operators"><a href="#comparison-operators">Comparison operators</a></h3>
<p>If <code>T</code> and <code>E</code> both implement <a href="https://doc.rust-lang.org/1.70.0/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd"><code>PartialOrd</code></a> then <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result&lt;T, E&gt;</code></a> will
derive its <a href="https://doc.rust-lang.org/1.70.0/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd"><code>PartialOrd</code></a> implementation.  With this order, an <a href="enum.Result.html#variant.Ok" title="variant frame_support::dispatch::result::Result::Ok"><code>Ok</code></a>
compares as less than any <a href="enum.Result.html#variant.Err" title="variant frame_support::dispatch::result::Result::Err"><code>Err</code></a>, while two <a href="enum.Result.html#variant.Ok" title="variant frame_support::dispatch::result::Result::Ok"><code>Ok</code></a> or two <a href="enum.Result.html#variant.Err" title="variant frame_support::dispatch::result::Result::Err"><code>Err</code></a>
compare as their contained values would in <code>T</code> or <code>E</code> respectively.  If <code>T</code>
and <code>E</code> both also implement <a href="https://doc.rust-lang.org/1.70.0/core/cmp/trait.Ord.html" title="trait core::cmp::Ord"><code>Ord</code></a>, then so does <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result&lt;T, E&gt;</code></a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert!</span>(<span class="prelude-val">Ok</span>(<span class="number">1</span>) &lt; <span class="prelude-val">Err</span>(<span class="number">0</span>));
<span class="kw">let </span>x: <span class="prelude-ty">Result</span>&lt;i32, ()&gt; = <span class="prelude-val">Ok</span>(<span class="number">0</span>);
<span class="kw">let </span>y = <span class="prelude-val">Ok</span>(<span class="number">1</span>);
<span class="macro">assert!</span>(x &lt; y);
<span class="kw">let </span>x: <span class="prelude-ty">Result</span>&lt;(), i32&gt; = <span class="prelude-val">Err</span>(<span class="number">0</span>);
<span class="kw">let </span>y = <span class="prelude-val">Err</span>(<span class="number">1</span>);
<span class="macro">assert!</span>(x &lt; y);</code></pre></div>
<h3 id="iterating-over-result"><a href="#iterating-over-result">Iterating over <code>Result</code></a></h3>
<p>A <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result</code></a> can be iterated over. This can be helpful if you need an
iterator that is conditionally empty. The iterator will either produce
a single value (when the <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result</code></a> is <a href="enum.Result.html#variant.Ok" title="variant frame_support::dispatch::result::Result::Ok"><code>Ok</code></a>), or produce no values
(when the <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result</code></a> is <a href="enum.Result.html#variant.Err" title="variant frame_support::dispatch::result::Result::Err"><code>Err</code></a>). For example, <a href="enum.Result.html#method.into_iter" title="method frame_support::dispatch::result::Result::into_iter"><code>into_iter</code></a> acts like
<a href="https://doc.rust-lang.org/1.70.0/core/iter/sources/once/fn.once.html" title="fn core::iter::sources::once::once"><code>once(v)</code></a> if the <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result</code></a> is <a href="enum.Result.html#variant.Ok" title="variant frame_support::dispatch::result::Result::Ok"><code>Ok(v)</code></a>, and like <a href="https://doc.rust-lang.org/1.70.0/core/iter/sources/empty/fn.empty.html" title="fn core::iter::sources::empty::empty"><code>empty()</code></a> if the
<a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result</code></a> is <a href="enum.Result.html#variant.Err" title="variant frame_support::dispatch::result::Result::Err"><code>Err</code></a>.</p>
<p>Iterators over <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result&lt;T, E&gt;</code></a> come in three types:</p>
<ul>
<li><a href="enum.Result.html#method.into_iter" title="method frame_support::dispatch::result::Result::into_iter"><code>into_iter</code></a> consumes the <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result</code></a> and produces the contained
value</li>
<li><a href="enum.Result.html#method.iter" title="method frame_support::dispatch::result::Result::iter"><code>iter</code></a> produces an immutable reference of type <code>&amp;T</code> to the
contained value</li>
<li><a href="enum.Result.html#method.iter_mut" title="method frame_support::dispatch::result::Result::iter_mut"><code>iter_mut</code></a> produces a mutable reference of type <code>&amp;mut T</code> to the
contained value</li>
</ul>
<p>See <a href="https://doc.rust-lang.org/1.70.0/core/option/index.html#iterating-over-option" title="mod core::option">Iterating over <code>Option</code></a> for examples of how this can be useful.</p>
<p>You might want to use an iterator chain to do multiple instances of an
operation that can fail, but would like to ignore failures while
continuing to process the successful results. In this example, we take
advantage of the iterable nature of <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result</code></a> to select only the
<a href="enum.Result.html#variant.Ok" title="variant frame_support::dispatch::result::Result::Ok"><code>Ok</code></a> values using <a href="https://doc.rust-lang.org/1.70.0/core/iter/traits/iterator/trait.Iterator.html#method.flatten" title="method core::iter::traits::iterator::Iterator::flatten"><code>flatten</code></a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>results = <span class="macro">vec!</span>[];
<span class="kw">let </span><span class="kw-2">mut </span>errs = <span class="macro">vec!</span>[];
<span class="kw">let </span>nums: Vec&lt;<span class="kw">_</span>&gt; = [<span class="string">&quot;17&quot;</span>, <span class="string">&quot;not a number&quot;</span>, <span class="string">&quot;99&quot;</span>, <span class="string">&quot;-27&quot;</span>, <span class="string">&quot;768&quot;</span>]
   .into_iter()
   .map(u8::from_str)
   <span class="comment">// Save clones of the raw `Result` values to inspect
   </span>.inspect(|x| results.push(x.clone()))
   <span class="comment">// Challenge: explain how this captures only the `Err` values
   </span>.inspect(|x| errs.extend(x.clone().err()))
   .flatten()
   .collect();
<span class="macro">assert_eq!</span>(errs.len(), <span class="number">3</span>);
<span class="macro">assert_eq!</span>(nums, [<span class="number">17</span>, <span class="number">99</span>]);
<span class="macro">println!</span>(<span class="string">&quot;results {results:?}&quot;</span>);
<span class="macro">println!</span>(<span class="string">&quot;errs {errs:?}&quot;</span>);
<span class="macro">println!</span>(<span class="string">&quot;nums {nums:?}&quot;</span>);</code></pre></div>
<h3 id="collecting-into-result"><a href="#collecting-into-result">Collecting into <code>Result</code></a></h3>
<p><a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result</code></a> implements the <a href="enum.Result.html#impl-FromIterator%3CResult%3CA,+E%3E%3E-for-Result%3CV,+E%3E" title="enum frame_support::dispatch::result::Result"><code>FromIterator</code></a> trait,
which allows an iterator over <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result</code></a> values to be collected into a
<a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result</code></a> of a collection of each contained value of the original
<a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result</code></a> values, or <a href="enum.Result.html#variant.Err" title="variant frame_support::dispatch::result::Result::Err"><code>Err</code></a> if any of the elements was <a href="enum.Result.html#variant.Err" title="variant frame_support::dispatch::result::Result::Err"><code>Err</code></a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v = [<span class="prelude-val">Ok</span>(<span class="number">2</span>), <span class="prelude-val">Ok</span>(<span class="number">4</span>), <span class="prelude-val">Err</span>(<span class="string">&quot;err!&quot;</span>), <span class="prelude-val">Ok</span>(<span class="number">8</span>)];
<span class="kw">let </span>res: <span class="prelude-ty">Result</span>&lt;Vec&lt;<span class="kw">_</span>&gt;, <span class="kw-2">&amp;</span>str&gt; = v.into_iter().collect();
<span class="macro">assert_eq!</span>(res, <span class="prelude-val">Err</span>(<span class="string">&quot;err!&quot;</span>));
<span class="kw">let </span>v = [<span class="prelude-val">Ok</span>(<span class="number">2</span>), <span class="prelude-val">Ok</span>(<span class="number">4</span>), <span class="prelude-val">Ok</span>(<span class="number">8</span>)];
<span class="kw">let </span>res: <span class="prelude-ty">Result</span>&lt;Vec&lt;<span class="kw">_</span>&gt;, <span class="kw-2">&amp;</span>str&gt; = v.into_iter().collect();
<span class="macro">assert_eq!</span>(res, <span class="prelude-val">Ok</span>(<span class="macro">vec!</span>[<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>]));</code></pre></div>
<p><a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result</code></a> also implements the <a href="enum.Result.html#impl-Product%3CResult%3CU,+E%3E%3E-for-Result%3CT,+E%3E" title="enum frame_support::dispatch::result::Result"><code>Product</code></a> and
<a href="enum.Result.html#impl-Sum%3CResult%3CU,+E%3E%3E-for-Result%3CT,+E%3E" title="enum frame_support::dispatch::result::Result"><code>Sum</code></a> traits, allowing an iterator over <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result</code></a> values
to provide the <a href="https://doc.rust-lang.org/1.70.0/core/iter/traits/iterator/trait.Iterator.html#method.product" title="method core::iter::traits::iterator::Iterator::product"><code>product</code></a> and
<a href="https://doc.rust-lang.org/1.70.0/core/iter/traits/iterator/trait.Iterator.html#method.sum" title="method core::iter::traits::iterator::Iterator::sum"><code>sum</code></a> methods.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v = [<span class="prelude-val">Err</span>(<span class="string">&quot;error!&quot;</span>), <span class="prelude-val">Ok</span>(<span class="number">1</span>), <span class="prelude-val">Ok</span>(<span class="number">2</span>), <span class="prelude-val">Ok</span>(<span class="number">3</span>), <span class="prelude-val">Err</span>(<span class="string">&quot;foo&quot;</span>)];
<span class="kw">let </span>res: <span class="prelude-ty">Result</span>&lt;i32, <span class="kw-2">&amp;</span>str&gt; = v.into_iter().sum();
<span class="macro">assert_eq!</span>(res, <span class="prelude-val">Err</span>(<span class="string">&quot;error!&quot;</span>));
<span class="kw">let </span>v = [<span class="prelude-val">Ok</span>(<span class="number">1</span>), <span class="prelude-val">Ok</span>(<span class="number">2</span>), <span class="prelude-val">Ok</span>(<span class="number">21</span>)];
<span class="kw">let </span>res: <span class="prelude-ty">Result</span>&lt;i32, <span class="kw-2">&amp;</span>str&gt; = v.into_iter().product();
<span class="macro">assert_eq!</span>(res, <span class="prelude-val">Ok</span>(<span class="number">42</span>));</code></pre></div>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.IntoIter.html" title="struct frame_support::dispatch::result::IntoIter">IntoIter</a></div><div class="desc docblock-short">An iterator over the value in a <a href="enum.Result.html#variant.Ok" title="variant frame_support::dispatch::result::Result::Ok"><code>Ok</code></a> variant of a <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.Iter.html" title="struct frame_support::dispatch::result::Iter">Iter</a></div><div class="desc docblock-short">An iterator over a reference to the <a href="enum.Result.html#variant.Ok" title="variant frame_support::dispatch::result::Result::Ok"><code>Ok</code></a> variant of a <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.IterMut.html" title="struct frame_support::dispatch::result::IterMut">IterMut</a></div><div class="desc docblock-short">An iterator over a mutable reference to the <a href="enum.Result.html#variant.Ok" title="variant frame_support::dispatch::result::Result::Ok"><code>Ok</code></a> variant of a <a href="enum.Result.html" title="enum frame_support::dispatch::result::Result"><code>Result</code></a>.</div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.Result.html" title="enum frame_support::dispatch::result::Result">Result</a></div><div class="desc docblock-short"><code>Result</code> is a type that represents either success (<a href="enum.Result.html#variant.Ok" title="variant frame_support::dispatch::result::Result::Ok"><code>Ok</code></a>) or failure (<a href="enum.Result.html#variant.Err" title="variant frame_support::dispatch::result::Result::Err"><code>Err</code></a>).</div></li></ul></section></div></main></body></html>